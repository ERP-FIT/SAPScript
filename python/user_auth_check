#refactor user permission system
#simple concept: assigned authorizations vs requested authorizations(target document)
#design modelling:1.define auth object for doctypes, module->doctype->auth object->auth field
#design modelling,2.define role and authorization, assign multi roles to user, user->role->authorization: auth field values
#authority checking:document.get_doc(), document.insert(), document.save(), model.delete_doc() for form view
#matching condition for frappe.get_list :frappe.db.query.execute matching condition for list view
#matching condition for set_query link field
#matching condition for global search
#matching condition for report view
#rule: user authorized for assigned authorizations only, for globally accessible doctypes, define as ignore permission at meta/doctype level
#rule, allow multi values per auth field, distinct values, value range(from, to), wild card(* and ?), variable from user master, e.g $user.name, user.department
#rule, authorizaiton for same auth objects can be set multi times per role, cross role to allow define separate auth level(create / change/ display)
#for different set of records
#rule: if mutli auth obj defined for doctype, authorization for all auth objects to be fulfilled
#rule: for ad hoc auth per doc and user combination, document sharing mechnism to be used
#
auth_objs_fields={'PO':[['po_org', 'act'],
						['po_org', 'org'],
						['po_type', 'act'],
						['po_type', 'type']],
				'SLE': [['sle_org','act'],
						['sle_org','plant'],
						['sle_org','location'],
						['sle_type','act'],
						['sle_type','type']],
				'SO':  [['so_org','act'],
						['so_org','org'],
						['so_type','act'],
						['so_type','type']]}
#auth_fields ={'po_org':['act','org'],'po_type':['act','type'],
#'sle_org':['act','plant','location'],'sle_type':['act','type'],'so_org':['act','org'],'so_type':['act','type'],}
#auth check cache, by auth key generated by doc's auth field values 
mylocals={'admin':{'PO': {},'SLE': {}}}
#auth: authorization,auth obj, auth field,value from, value to	  
authorizations=[[1,'po_org','act','01',''],
			  [1,'po_org','act','02','04'],
			  [1,'po_org','org','3000',''],	  
			  [2,'po_org','act','06','08'],
			  [2,'po_org','org','4000',''],
			  [2,'po_org','org','7000','8000'],
			  [22,'po_org','act','06','08'],
			  [22,'po_org','org','4000',''],
			  [22,'po_org','org','7000','8000'],
			  [3,'po_org','act','A*',''],
			  [3,'po_org','org','90?0',''],
			  [4,'po_type','act','01','07'],
			  [4,'po_type','type','nb',''],
			  [5,'po_type','act','01',''],
			  [5,'po_type','type','db',''],
			  [11,'sle_org','act','3',''],
			  [11,'sle_org','plant','1000',''],
			  [11,'sle_org','plant','3000','4000'],
			  [11,'sle_org','plant','6000',''],
			  [11,'sle_org','plant','70*',''],
			  [11,'sle_org','location','r201',''],
			  [12,'sle_org','act','3',''],
			  [12,'sle_org','plant','a000',''],
			  [12,'sle_org','plant','a000','b000'],
			  [12,'sle_org','location','r221',''],
			  [13,'sle_type','act','3',''],
			  [13,'sle_type','type','nb',''],
			  [14,'sle_type','act','3',''],
			  [14,'sle_type','type','*',''],
			  [15,'so_type','act','*',''],
			  [15,'so_type','type','*','']
			  ]
	  	  
docs=[{'doctype':'PO','type':'nb','act':'01','org':'3000'},
	  {'doctype':'PO','type':'nb','act':'03','org':'3000'},
	  {'doctype':'PO','type':'nb','act':'07','org':'8000'},
	  {'doctype':'PO','type':'nb','act':'08','org':'8000'},
	  {'doctype':'PO','type':'sb','act':'A1','org':'9000'},
	  {'doctype':'PO','type':'nb','act':'01','org':'5000'},
	  {'doctype':'PO','type':'nb','act':'07','org':'8500'},
	  {'doctype':'PO','type':'nb','act':'B','org':'9100'},
	  {'doctype':'PO','type':'nb','act':'A','org':'9000'},
	  {'doctype':'SLE','type':'nb','act':'3','plant':'13000','location':'r201'}]

# Python program to match wild card characters 
  
# The main function that checks if two given strings match. 
# The first string may contain wildcard characters 
def match(first, second): 
  
    # If we reach at the end of both strings, we are done 
    if len(first) == 0 and len(second) == 0: 
        return True
  
    # Make sure that the characters after '*' are present 
    # in second string. This function assumes that the first 
    # string will not contain two consecutive '*' 
    if len(first) > 1 and first[0] == '*' and  len(second) == 0: 
        return False
  
    # If the first string contains '?', or current characters 
    # of both strings match 
    if (len(first) > 1 and first[0] == '?') or (len(first) != 0
        and len(second) !=0 and first[0] == second[0]): 
        return match(first[1:],second[1:]); 
  
    # If there is *, then there are two possibilities 
    # a) We consider current character of second string 
    # b) We ignore current character of second string. 
    if len(first) !=0 and first[0] == '*': 
        return match(first[1:],second) or match(first,second[1:]) 
  
    return False	

def get_auth_key(act, doc='', doctype=''):
	""" for doctype: dcotype:act
	    for doc: field1:field2:act
	"""
	if not doc and not doctype:
		return ''
	if not doc:
		return '%s:%s' %(doctype, act)
	else:
		doc_for_auth ={}		
		for (auth_obj,auth_field) in auth_objs_fields[doc['doctype']]:					
			if auth_field !='act' and auth_field not in doc_for_auth:
				doc_for_auth[auth_field] = doc.get(auth_field)
		auth_key = '%s:%s' %(':'.join(doc_for_auth.values()), act)
		
		return auth_key
	
def auth_check(doc, act, user,  doctype='', trace=0):
	"""wrapper of _auth_check with added feature for caching"""
	doctype = doc.get('doctype') if doc else doctype
	if not doctype in mylocals[user].keys():
		mylocals[user][doctype]={}
	auth_key = get_auth_key(act, doc, doctype)	
	if not auth_key in mylocals[user].get(doctype).keys():
		mylocals[user][doctype][auth_key] = _auth_check(doc, act, user, doctype, trace)
	return mylocals[user][doctype].get(auth_key)
	
def get_authorization(doctype, act='03', user=None, no_wildcard_rec = 0):
	"""get authorization records list from cache
		0. auth records to be ordered by auth obj, auth ID and auth field
		1. remove duplicate records from different roles
		2. remove records for auth obj with at least one record wildcard for all fields
	"""
	doctype_auth_objs = [j[0] for j in auth_objs_fields[doctype]]	
	auths= [i for i in authorizations if i[1] in doctype_auth_objs and i[2] !='act']
	existing_auth = {}  # auth rec without ID field to check duplicate auth records
	id_auth,obj_auth, auth_rec,result = [],[],[],[]
	id_wildcard,obj_wildcard = False,False
	count = len(auths)
	for i in range(count):
		id_auth.append(auths[i])
		auth_rec.append(auths[i][1:])  
		id_wildcard = True if auths[i][3] == '*' else False
		next_auth_id = auths[i+1][0] if i < count-1 else ''
		next_auth_obj = auths[i+1][1] if i < count-1 else ''
		if auths[i][0] != next_auth_id:
			auth_rec_str = repr(auth_rec)
			if not auth_rec_str in existing_auth.keys():
				existing_auth.update({auth_rec_str:1})
				obj_auth.extend(id_auth)				
			if id_wildcard:
				obj_wildcard = True
			id_wildcard = False
			id_auth = []
			auth_rec = []
		if auths[i][1] != next_auth_obj:
			if (no_wildcard_rec and obj_wildcard) or not no_wildcard_rec:
				result.extend(obj_auth)
			obj_wildcard = False
			obj_auth = []
			existing_auth = {}
	return result
			

def get_descendants(doctype, field, value_from):
	""" support using parent value on the value from """
	result = value_from
	# meta = frappe.get_meta(doctype)
	# f = meta.get_field(field)
	# if f.fieldtype=='Link' and frappe.get_meta(f.options).is_nested_set():
		# values = frappe.db.get_descendants(f.options, value_from)		
		# return result
	return result



def check_field(doctype, field, field_value, value_from, value_to=None, user=None):
	""" checking doc field against value from/value assigned to user via role authorization detail
		1. wildcard * matches all 
		2. wildcard as part of the text, works as like % in SQL
		3. variable field from user master, $user.company, will substitue with current user master field
		4. value from and value to,  works as between(inclusive) in SQL
		5. simple value, works as equal(=) in SQL
	"""
	if value_from == '*':
		return True
	if not value_to:
		if any(c in value_from for c in ['*','?']):
			return match(value_from, field_value)
		else: # to do handle get descendant
			#if '$user.' in value_from:				
			#	value_from = frappe.get_doc('User', user).get(value_from.split('.')[1])
			if field_value == value_from:
				return True
			else:
				descendants = get_descendants(doctype, field, value_from)
				if descendants == field_value:
					return False
				else:
					return field_value in descendants			
	else:
		return value_from <= field_value <= value_to		
	
	
def _auth_check(doc, act, user, doctype=None, trace=0):
	"""1.doctype level check:only act field is relevant
	   2.doc level check:
			2.1 at least one valid auth records exist, to support adding more auth objs later for new user only,
			 no impact to existing users without authorizations for new auth obj 
			2.2 for doc field with empty value, check is OK
			2.3 Logic of combining all relevant authorizations per each authorizationID
				2.3.1 same authorizationID, same auth obj,different auth field: AND
				2.3.2 different authorizationID, same auth obj: OR
				2.3.3 different authorizationID, different auth obj: AND
				2.3.4 field level auth check: refer to check field documentation
	"""
	result = []
	doctype = doc.get('doctype') if doc else doctype
	auth_objs = auth_objs_fields.get(doctype)
	if not auth_objs:
		return True
	auths = get_authorization(doctype)	
	if not doc:
		authorization_objects = set([j[0] for j in auth_objs])
		for auth in auths:
			if auth[1] in authorization_objects and auth[2] == 'act' and (auth[3] in [act,'*'] 
				or auth[3]<=act<=auth[4] or match(auth[3], act)):
				return True
			return False
	else:
		pre_auth_obj = ''
		for (auth_obj,auth_field) in auth_objs:
			#reset when auth objects changed, different auth obj to be connected by AND in SQL where clause
			if auth_obj != pre_auth_obj:
				result = []
			else:
				pre_auth_obj = auth_obj
			obj_auths = [auth for auth in auths if auth[1] == auth_obj]	
			if not obj_auths:
				continue						
			check_value = act if auth_field=='act' else doc.get(auth_field)
			if not check_value:  # bypass check for empty to be checked doc field
				auth = [i[0] for i in obj_auths if i[2]== auth_field]
			else:				
				auth = [i[0] for i in obj_auths if i[2]== auth_field and check_field(doctype,auth_field, check_value, i[3],i[4])]			
			if not auth:				
				return False
			else:
				result = set(result) & set(auth) if result else set(auth)			
			if not result:				
				return False		
	return len(result)>0

import collections	
def get_match_conditions(doctype, act='read', user=None):
	""" append auth relevant where condition to list display via get_list/get_all or report query
		for logic details, please check the _auth_check documentation
	"""
	def build_condition(auth):
		"""generate SQL where condition per auth record for single field"""
		if auth[3] and auth[4]:
			condition = "%s between '%s' and '%s'" %(auth[2], auth[3], auth[4])
		elif '*' in auth[3]:
			condition = "%s like '%s'" %(auth[2], auth[3].replace('*', '%'))
		else:
			#if '$user.' in auth[3]:				
			#	auth[3] = frappe.get_doc('User', user).get(auth[3].split('.')[1])
			descendants = get_descendants(doctype, auth[2], auth[3])
			if descendants == auth[3]:
				condition = "%s = '%s'" %(auth[2], auth[3])
			else:
				condition = "%s in (%s)" %(auth[2], ','.join(["'%s'" %(i) for i in descendants]))
		return condition
		
	if not 'match_condition' in mylocals[user].get(doctype).keys():			
		auths = get_authorization(doctype)	
		# extract auth IDS by of the activity/operation
		auth_IDS = [auth[0] for auth in auths if auth[3]==act and 
			(auth[3] in [act,'*'] or auth[3]<=act<=auth[4] or match(auth[3], act))]			
		auth_conditions= {}							
		# remove duplicate authorizations
		for auth_ID in auth_IDS:
			auth_values = [i for i in auths if i[0] == auth_ID  and i[2]!='act']
			auth_obj = auth_values[0][1]
			auth_obj_auths = auth_conditions.get(auth_obj)
			if auth_obj_auths:
				auth_obj_auths.extend(auth_values)
			else:
				auth_conditions[auth_obj] = auth_values
		# build filter condition per authorizaiton/auth obj & auth field
		auth_conditions = collections.OrderedDict(sorted(auth_conditions.items()))		
		result = pre_obj = obj_conn_str = ''
		for obj, authes in auth_conditions.items():
			if pre_obj and result:		
				if obj == pre_obj:
					obj_conn_str = conn_str = ')) or ('
				else:
					obj_conn_str = ')) and ('
			else:
				obj_conn_str = '('  
			pre_obj = obj		
			pre_auth_ID = pre_field = obj_condition= ''		
			first_field = pre_wildcard = cur_wildcard = False
			for auth in authes:			
				if not pre_field:
					conn_str = '('
					first_field = True
				else:
					if auth[0] == pre_auth_ID:
						if auth[2] == pre_field:
							conn_str = ' or '
						else:
							first_field = True
							pre_wildcard = cur_wildcard
							cur_wildcard = False
							conn_str = ') and ('					
					else:
						if cur_wildcard:
							break
						first_field = True
						conn_str = ')) or (('					
				if auth[3] == '*' and (first_field or pre_wildcard):
					cur_wildcard = True
				pre_auth_ID, pre_field = auth[0],auth[2]			 
				field_condition=build_condition(auth)
				#print((auth,field_condition))
				obj_condition = '%s%s%s' %(obj_condition, conn_str, field_condition)
			if not cur_wildcard:
				result += obj_conn_str + obj_condition
		if result:
			result += "))"	
			
		mylocals[user].get(doctype).update({'match_condition': result})
		
	return mylocals[user].get(doctype).get('match_condition')
		
def test():	
	for doc in docs:
		print(auth_check(doc, doc['act'],'admin'))
	auth_check('', '03', 'admin','PO')
	auth_check('', '53', 'admin','PO')
	auth_check('', '53', 'admin','SO')
	
test()
print('get matching condition:')
print(get_match_conditions('SLE', '3', 'admin'))
