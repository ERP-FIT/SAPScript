#refactor user permission system
#simple concept: assigned authorizations vs requested authorizations(target document)
#design modelling:1.define auth object for doctypes, module->doctype->auth object->auth field
#design modelling,2.define role and authorization, assign multi roles to user, user->role->authorization: auth field values
#authority checking:document.get_doc(), document.insert(), document.save(), model.delete_doc() for form view
#matching condition for frappe.get_list :frappe.db.query.execute matching condition for list view
#matching condition for set_query link field
#matching condition for global search
#matching condition for report view
#rule: user authorized for assigned authorizations only, for globally accessible doctypes, define as ignore permission at meta/doctype level
#rule, allow multi values per auth field, distinct values, value range(from, to), wild card(* and ?),
#rule, authorizaiton for same auth objects can be set multi times per role, cross role to allow define separate auth level(create / change/ display)
#for different set of records
#rule: if mutli auth obj defined for doctype, authorization for all auth objects to be fulfilled
#rule: for ad hoc auth per doc and user combination, document sharing mechnism to be used
#


auth_objects={'PO':['PO_Org','PO_Type'],'SLE':['ste_org']}
auth_fields ={'PO_Org':['act','org'],'PO_Type':['act','type']}
#auth check cache, by auth key generated by doc's auth field values 
mylocals={'admin':{'PO': {}}}
#auth: authorization,auth field,value from, value to	  
auths=[[1,'act','01',''],
	  [1,'act','02','04'],
	  [1,'org','3000',''],	  
	  [2,'act','06','08'],
	  [2,'org','4000',''],
	  [2,'org','7000','8000'],
	  [3,'act','A*',''],
	  [3,'org','90?0',''],
	  [4,'act','01','07'],
	  [4,'type','nb',''],
	  [5,'act','01',''],
	  [5,'type','db','']
	  ]
	  	  
docs=[{'doctype':'PO','type':'nb','act':'01','org':'3000'},
	  {'doctype':'PO','type':'nb','act':'03','org':'3000'},
	  {'doctype':'PO','type':'nb','act':'07','org':'8000'},
	  {'doctype':'PO','type':'nb','act':'08','org':'8000'},
	  {'doctype':'PO','type':'nb','act':'A1','org':'9000'},
	  {'doctype':'PO','type':'nb','act':'01','org':'5000'},
	  {'doctype':'PO','type':'nb','act':'07','org':'8500'},
	  {'doctype':'PO','type':'nb','act':'B','org':'9100'},
	  {'doctype':'PO','type':'nb','act':'A','org':'9000'}]

# Python program to match wild card characters 
  
# The main function that checks if two given strings match. 
# The first string may contain wildcard characters 
def match(first, second): 
  
    # If we reach at the end of both strings, we are done 
    if len(first) == 0 and len(second) == 0: 
        return True
  
    # Make sure that the characters after '*' are present 
    # in second string. This function assumes that the first 
    # string will not contain two consecutive '*' 
    if len(first) > 1 and first[0] == '*' and  len(second) == 0: 
        return False
  
    # If the first string contains '?', or current characters 
    # of both strings match 
    if (len(first) > 1 and first[0] == '?') or (len(first) != 0
        and len(second) !=0 and first[0] == second[0]): 
        return match(first[1:],second[1:]); 
  
    # If there is *, then there are two possibilities 
    # a) We consider current character of second string 
    # b) We ignore current character of second string. 
    if len(first) !=0 and first[0] == '*': 
        return match(first[1:],second) or match(first,second[1:]) 
  
    return False	
	
def get_auth_key(doc):
	doc_for_auth ={}
	for auth_obj in auth_objects[doc['doctype']]:		
		for auth_field in auth_fields[auth_obj]:
			if auth_field not in doc_for_auth:
				doc_for_auth[auth_field] = doc.get(auth_field)
	auth_key = ':'.join(doc_for_auth.values())
	
	return auth_key
	
def auth_check(doc, act, user):
	#if user='admin' or doc.doctype.ignore_permission:
	#	return True
	#if not check_shared_doc():
	#	return _auth_check(doc, act, user)
	auth_key = get_auth_key(doc)
	if not mylocals[user][doc['doctype']].get(auth_key):
		mylocals[user][doc['doctype']][auth_key] = _auth_check(doc, act, user)
	return mylocals[user][doc['doctype']].get(auth_key)
	
def _auth_check(doc,act, user):		
	for auth_obj in auth_objects[doc['doctype']]:
		result = []
		for auth_field in auth_fields[auth_obj]:
			check_value = act if auth_field=='act' else doc[auth_field]
			auth = [i[0] for i in auths if i[1]== auth_field and (i[2]==check_value or i[2] == '*'
						or i[2]<=check_value<=i[3] or match(i[2], check_value))]
			if not auth:
				return False
			else:
				result = set(result) & set(auth) if result else set(auth)			
		if not result:
			return False
	return len(result)>0
		
def test():	
	for doc in docs:
		print(auth_check(doc, doc['act'],'admin'))
		
test()
